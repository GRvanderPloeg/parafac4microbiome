---
title: "modelSelection"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{modelSelection}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(parafac4microbiome)
library(dplyr)
library(ggplot2)
library(ggpubr)
```

```{r Fujita num comp selection}
# For computational purposes we deviate from the default settings
X = Fujita2023$data
assessment = assessNumComponents(X,
                                 minNumComponents = 1,
                                 maxNumComponents = 3,
                                 numRepetitions = 10,
                                 ctol=1e-6,
                                 maxit=500)

plotModelMetric(assessment$metrics, "numIterations")
plotModelMetric(assessment$metrics, "SSE")
plotModelMetric(assessment$metrics, "CORCONDIA")
plotModelMetric(assessment$metrics, "varExp")

# Model stability check using jack-knifing
for(f in 1:3){
  output = modelStabilityCheck(Fujita2023$data,
                               Fujita2023$sampleMetadata,
                               numComponents=f,
                               numRepetitions=10)
  print(plotModelStability(output))
}

# Tucker congruence coefficients
for(f in 2:3){
  print(plotModelTCCs(assessment$metrics$TCC[[f]]))
  print(plotOverallTCCs(assessment$metrics$TCC[[f]]))
}

# Here we decide on selecting the best 3-component model, i.e. explaining the largest amount of variation.
# Alternative: select based on maximum CORCONDIA.
numComponents = 3
modelChoice = which(assessment$metrics$varExp[,numComponents] == max(assessment$metrics$varExp[,numComponents]))
finalModel = assessment$models[[numComponents]][[modelChoice]]

# Convert model output to plottable data
subjectMetadata = Fujita2023$sampleMetadata %>%
filter(treat2=="WC") %>%
select(replicate.id) %>%
unique()

featureMetadata = Fujita2023$taxonomy

conditionMetadata = Fujita2023$sampleMetadata %>%
select(time) %>%
unique()

metadataPerMode = list(subjectMetadata, featureMetadata, conditionMetadata)
convertedModel = convertModelFormat(finalModel, metadataPerMode)

plotPARAFACmodel(convertedModel,
  colourCols = c("", "Genus", ""),
  legendTitles = c("", "Genus", ""),
  xLabels = c("Replicate", "Feature index", "Time point"),
  legendColNums = c(0,5,0),
  arrangeModes = c(FALSE, TRUE, FALSE),
  continuousModes = c(FALSE,FALSE,TRUE),
  overallTitle = "Fujita PARAFAC model")
```

```{r Shao comp selection}
# For computational purposes we deviate from the default settings
X = Shao2019$data
assessment = assessNumComponents(X,
                                 minNumComponents = 1,
                                 maxNumComponents = 2,
                                 numRepetitions = 10,
                                 ctol=1e-6,
                                 maxit=500)

plotModelMetric(assessment$metrics, "numIterations")
plotModelMetric(assessment$metrics, "SSE")
#plotModelMetric(assessment$metrics, "CORCONDIA")
plotModelMetric(assessment$metrics, "varExp")

# Model stability check using jack-knifing
for(f in 1:2){
  output = modelStabilityCheck(Shao2019$data,
                               Shao2019$sampleMetadata,
                               numComponents=f,
                               numRepetitions=10)
  print(plotModelStability(output))
}

# Tucker congruence coefficients
plotModelTCCs(assessment$metrics$TCC[[2]])
plotOverallTCCs(assessment$metrics$TCC[[2]])

# Here we decide on selecting the best 2-component model, i.e. explaining the largest amount of variation.
# Alternative: select based on maximum CORCONDIA.
numComponents = 2
modelChoice = which(assessment$metrics$varExp[,numComponents] == max(assessment$metrics$varExp[,numComponents]))
finalModel = assessment$models[[numComponents]][[modelChoice]]

# Convert model output to plottable data
subjectMetadata = Shao2019$sampleMetadata %>% 
  select(Individual, Delivery_mode) %>%
  arrange(Individual) %>%
  unique()

featureMetadata = Shao2019$taxonomy

conditionMetadata = Shao2019$sampleMetadata %>% select(Time_point) %>% unique()

metadataPerMode = list(subjectMetadata, featureMetadata, conditionMetadata)
convertedModel = convertModelFormat(finalModel, metadataPerMode)

plotPARAFACmodel(convertedModel,
  colourCols = c("Delivery_mode", "phylum", ""),
  legendTitles = c("Delivery mode", "Phylum", ""),
  xLabels = c("Subject index", "Feature index", "Time index"),
  legendColNums = c(3,5,0),
  arrangeModes = c(TRUE, TRUE, FALSE),
  continuousModes = c(FALSE,FALSE,TRUE),
  overallTitle = "Shao2019 PARAFAC model")
```

```{r vanderPloeg comp selection}
# For computational purposes we deviate from the default settings
X = vanderPloeg2024$data
assessment = assessNumComponents(X,
                                 minNumComponents = 1,
                                 maxNumComponents = 3,
                                 numRepetitions = 10,
                                 ctol=1e-6,
                                 maxit=500)

assessment = assessNumComponents(X, minNumComponents = 1, maxNumComponents = 5, numRepetitions = 10, ctol=1e-6, maxit=2500)
plotModelMetric(assessment$metrics, "numIterations")
plotModelMetric(assessment$metrics, "SSE")
plotModelMetric(assessment$metrics, "CORCONDIA")
plotModelMetric(assessment$metrics, "varExp")

# Model stability check using jack-knifing
for(f in 1:5){
  output = modelStabilityCheck(vanderPloeg2024$data,
                               vanderPloeg2024$sampleMetadata,
                               numComponents=f,
                               numRepetitions=10)
  print(plotModelStability(output))
}

# Tucker congruence coefficients
for(f in 2:5){
  print(plotModelTCCs(assessment$metrics$TCC[[f]]))
  print(plotOverallTCCs(assessment$metrics$TCC[[f]]))
}

# Here we decide on selecting the best 2-component model, i.e. explaining the largest amount of variation.
# Alternative: select based on maximum CORCONDIA.
numComponents = 2
modelChoice = which(assessment$metrics$varExp[,numComponents] == max(assessment$metrics$varExp[,numComponents]))
finalModel = assessment$models[[numComponents]][[modelChoice]]

# Convert model output to plottable data
subjectMetadata = vanderPloeg2024$subjectMetadata %>% 
  select(subject, RFgroup) %>% 
  arrange(subject) %>%
  unique()

featureMetadata = vanderPloeg2024$taxonomy

conditionMetadata = vanderPloeg2024$subjectMetadata %>%
  select(visit) %>%
  arrange(visit) %>%
  unique()

metadataPerMode = list(subjectMetadata, featureMetadata, conditionMetadata)
convertedModel = convertModelFormat(finalModel, metadataPerMode)

plotPARAFACmodel(convertedModel,
  colourCols = c("RFgroup", "Phylum", ""),
  legendTitles = c("RF group", "Phylum", ""),
  xLabels = c("Subject index", "Feature index", "Time index"),
  legendColNums = c(2,5,0),
  arrangeModes = c(TRUE, TRUE, FALSE),
  continuousModes = c(FALSE,FALSE,TRUE),
  overallTitle = "vanderPloeg2024 PARAFAC model")
```
