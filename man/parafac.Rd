% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/parafac.R
\name{parafac}
\alias{parafac}
\title{Parallel Factor Analysis-1}
\usage{
parafac(
  X,
  nfac,
  nstart = 10,
  const = NULL,
  control = NULL,
  Afixed = NULL,
  Bfixed = NULL,
  Cfixed = NULL,
  Dfixed = NULL,
  Astart = NULL,
  Bstart = NULL,
  Cstart = NULL,
  Dstart = NULL,
  Astruc = NULL,
  Bstruc = NULL,
  Cstruc = NULL,
  Dstruc = NULL,
  Amodes = NULL,
  Bmodes = NULL,
  Cmodes = NULL,
  Dmodes = NULL,
  maxit = 500,
  ctol = 1e-04,
  parallel = FALSE,
  cl = NULL,
  output = c("best", "all"),
  verbose = TRUE,
  backfit = FALSE
)
}
\arguments{
\item{X}{Three-way data array with dim=c(I,J,K) or four-way data array with dim=c(I,J,K,L). Missing data are allowed (see Note).}

\item{nfac}{Number of factors.}

\item{nstart}{Number of random starts.}

\item{const}{Character vector of length 3 or 4 giving the constraints for each mode (defaults to unconstrained). See \link[CMLS:const]{CMLS::const} for the 24 available options.}

\item{control}{List of parameters controlling options for smoothness constraints. This is passed to \link[multiway:const.control]{multiway::const.control}, which describes the available options.}

\item{Afixed}{Used to fit model with fixed Mode A weights.}

\item{Bfixed}{Used to fit model with fixed Mode B weights.}

\item{Cfixed}{Used to fit model with fixed Mode C weights.}

\item{Dfixed}{Used to fit model with fixed Mode D weights.}

\item{Astart}{Starting Mode A weights. Default uses random weights.}

\item{Bstart}{Starting Mode B weights. Default uses random weights.}

\item{Cstart}{Starting Mode C weights. Default uses random weights.}

\item{Dstart}{Starting Mode D weights. Default uses random weights.}

\item{Astruc}{Structure constraints for Mode A weights. See Note.}

\item{Bstruc}{Structure constraints for Mode B weights. See Note.}

\item{Cstruc}{Structure constraints for Mode C weights. See Note.}

\item{Dstruc}{Structure constraints for Mode D weights. See Note.}

\item{Amodes}{Mode ranges for Mode A weights (for unimodality constraints). See Note.}

\item{Bmodes}{Mode ranges for Mode B weights (for unimodality constraints). See Note.}

\item{Cmodes}{Mode ranges for Mode C weights (for unimodality constraints). See Note.}

\item{Dmodes}{Mode ranges for Mode D weights (for unimodality constraints). See Note.}

\item{maxit}{Maximum number of iterations.}

\item{ctol}{Convergence tolerance (R^2 change).}

\item{parallel}{Logical indicating if \link[parallel:clusterApply]{parallel::parLapply} should be used. See Examples.}

\item{cl}{Cluster created by \link[parallel:makeCluster]{parallel::makeCluster}. Only used when parallel=TRUE.}

\item{output}{Output the best solution (default) or output all nstart solutions.}

\item{verbose}{If TRUE, fitting progress is printed via \link[utils:txtProgressBar]{utils::txtProgressBar}. Ignored if parallel=TRUE.}

\item{backfit}{Should backfitting algorithm be used for \link[CMLS:cmls]{CMLS::cmls}?}
}
\value{
If output = "best", returns an object of class "parafac" with the following elements:
#' \describe{
\item{A}{Mode A weight matrix.}
\item{B}{Mode B weight matrix.}
\item{C}{Mode C weight matrix.}
\item{D}{Mode D weight matrix.}
\item{SSE}{Sum of Squared Errors.}
\item{Rsq}{R-squared value.}
\item{GCV}{Generalized Cross-Validation.}
\item{edf}{Effective degrees of freedom.}
\item{iter}{Number of iterations.}
\item{cflag}{Convergence flag. See Note.}
\item{const}{See argument const.}
\item{control}{See argument control.}
\item{fixed}{Logical vector indicating whether 'fixed' weights were used for each mode.}
\item{struc}{Logical vector indicating whether 'struc' constraints were used for each mode.}
}
Otherwise returns a list of length nstart where each element is an object of class "parafac".
}
\description{
Fits Richard A. Harshman's Parallel Factors (Parafac) model to 3-way or 4-way data arrays. Parameters are estimated via alternating least squares with optional constraints.
}
\note{
Missing data should be specified as NA values in the input X. The missing data are randomly initialized and then iteratively imputed as a part of the algorithm.

Structure constraints should be specified with a matrix of logicals (TRUE/FALSE), such that FALSE elements indicate a weight should be constrained to be zero. Default uses unstructured weights, i.e., a matrix of all TRUE values.

When using unimodal constraints, the *modes inputs can be used to specify the mode search range for each factor. These inputs should be matrices with dimension c(2,nfac) where the first row gives the minimum mode value and the second row gives the maximum mode value (with respect to the indicies of the corresponding weight matrix).

Output cflag gives convergence information: cflag = 0 if algorithm converged normally, cflag = 1 if maximum iteration limit was reached before convergence, and cflag = 2 if algorithm terminated abnormally due to a problem with the constraints.
}
\examples{
library(multiway)
#' ##########   3-way example   ##########

# create random data array with Parafac structure
set.seed(3)
mydim <- c(50, 20, 5)
nf <- 3
Amat <- matrix(rnorm(mydim[1]*nf), nrow = mydim[1], ncol = nf)
Bmat <- matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf)
Cmat <- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Xmat <- tcrossprod(Amat, krprod(Cmat, Bmat))
Xmat <- array(Xmat, dim = mydim)
Emat <- array(rnorm(prod(mydim)), dim = mydim)
Emat <- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X <- Xmat + Emat

# fit Parafac model (unconstrained)
pfac <- parafac(X, nfac = nf, nstart = 1)
pfac

# fit Parafac model (non-negativity on Modes B and C)
pfacNN <- parafac(X, nfac = nf, nstart = 1,
            const = c("uncons", "nonneg", "nonneg"))
pfacNN

# check solution
Xhat <- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)

# reorder and resign factors
pfac$B[1:4,]
pfac <- reorder(pfac, c(3,1,2))
pfac$B[1:4,]
pfac <- resign(pfac, mode="B")
pfac$B[1:4,]
Xhat <- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)

# rescale factors
colSums(pfac$B^2)
colSums(pfac$C^2)
pfac <- rescale(pfac, mode = "C", absorb = "B")
colSums(pfac$B^2)
colSums(pfac$C^2)
Xhat <- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)


##########   4-way example   ##########

# create random data array with Parafac structure
set.seed(4)
mydim <- c(30,10,8,10)
nf <- 4
aseq <- seq(-3, 3, length.out = mydim[1])
Amat <- cbind(dnorm(aseq), dchisq(aseq+3.1, df=3),
      dt(aseq-2, df=4), dgamma(aseq+3.1, shape=3, rate=1))
Bmat <- svd(matrix(runif(mydim[2]*nf), nrow = mydim[2], ncol = nf), nv = 0)$u
Cmat <- matrix(runif(mydim[3]*nf), nrow = mydim[3], ncol = nf)
Cstruc <- Cmat > 0.5
Cmat <- Cmat * Cstruc
Dmat <- matrix(runif(mydim[4]*nf), nrow = mydim[4], ncol = nf)
Xmat <- tcrossprod(Amat, krprod(Dmat, krprod(Cmat, Bmat)))
Xmat <- array(Xmat, dim = mydim)
Emat <- array(rnorm(prod(mydim)), dim = mydim)
Emat <- nscale(Emat, 0, ssnew = sumsq(Xmat))   # SNR = 1
X <- Xmat + Emat

# fit Parafac model (unimodal and smooth A, orthogonal B,
#                    non-negative and structured C, non-negative D)
pfac <- parafac(X, nfac = nf, nstart = 1, Cstruc = Cstruc,
            const = c("unismo", "orthog", "nonneg", "nonneg"))
pfac

# check solution
Xhat <- fitted(pfac)
sum((Xmat - Xhat)^2) / prod(mydim)
congru(Amat, pfac$A)
crossprod(pfac$B)
pfac$C
Cstruc

}
